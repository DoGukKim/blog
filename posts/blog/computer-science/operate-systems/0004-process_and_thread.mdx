---
description: '프로그램과 프로세스는 무엇이 다르고 스레드는 무엇일까? 프로세스와 스레드에 대해 알아보자!'
date: 2022-08-17 18:35:40
publish: true
tags: ['computer-science', 'operate-systems']
title: '프로세스와 스레드'
thumbnail: ''
---

## 프로그램과 프로세스 차이

`프로그램`은 명령문들이 메모리에 올라가지 않고 저장장치에 정적으로 저장되어있는 상태를 말한다.  
`프로세스`는 운영체제에 의해 명령문들이 메모리에 올라가고 제어블록(PCU)이 생성되어있는 준비 상태를 말한다.

<Space />

## 제어블록(Process Control Block)

운영체제가 프로세스 관리함에 있어 필요한 메타 정보가 담긴 자료구조다.  
프로그램이 실행되면 운영체제에 의해 제어블록이 생성된다.

### 구조

제어블록에는 여러 메타 정보가 담겨있는데 간략하게 아래와 같다.

- 포인터: 제어블록에 위치와 연결 대상을 파악할 때 사용되는 정보다. 연결 리스트로 구현된 큐에 포인터를 생각하면 된다.
- 상태: 프로세스의 상태를 나타내며 생성, 준비, 실행, 대기, 보류 대기, 보류 준비, 종료로 분류된다.
- PID: 프로세스 고유 식별자를 나타내는 정보다.
- 각종 레지스터: 프로그램 카운터, 메모리 버퍼, 메모리 주소 등 여러 레지스터 정보다.
- 프로세스 우선순위: 프로세스는 대기 큐에서 우선순위에 따라 스케줄링되는데, 이에 대한 우선순위 정보다.
- PPID: 부모 프로세스 식별자를 나타내는 정보다.
- PCID: 자식 프로세스 식별자를 나타내는 정보다.
- 메모리 관리 정보: 메모리에 올라간 프로세스 위치에 대한 정보를 나타내며,  
  경계 레지스터 또는 한계 레지스터, 페이지 또는 세그멘테이션 테이블 정보다.  
  이것들에 대해선 추후 가상 메모리 포스팅에 자세히 설명할 예정입니다.

<Space />

## 프로세스 상태

프로세스가 생성되고 종료되어 제거되기까지 과정에서 상태에 변화가 발생한다.  
크게 `활성`, `휴식`, `보류` 상태로 구분된다.

### 활성 상태

- 생성: 운영체제에 의해 메모리에 할당되고 제어 블록이 생성된 상태다.
- 준비: 생성된 프로세스는 준비 큐 안에서 CPU 자원을 얻을 순서를 기다린다.  
  준비 상태에 있는 프로세스를 CPU 스케줄러가 `dispatch(PID)`를 실행해 특정 프로세스를 실행 상태로 바꾼다.
- 실행: 프로세스가 CPU 자원을 받아 주어진 타임 슬라이스 동안 작업이 진행된다.  
  만약 주어진 시간에 작업을 완료하면 `exit(PID)`를, 그렇지 않다면 `timeout(PID)`가 호출되어 준비 큐로 돌아간다.
- 대기: 프로세스가 실행되어 `입출력`을 요청하면 완료까지 기다리는 상태를 말한다.  
   입출력 완료 인터럽트가 오면 `wakeup(PID)`로 해당 프로세스를 준비 상태로 옮긴다.  
  `blocking`과 `non-blocking`이 있으며 blocking은 입출력 요청 이후 대기상태로 옮겨지지만,  
   non-blocking은 요청을 운영체제에 맡기고 실행상태에 지속적으로 놓여있는 것을 말한다.
- 완료: 프로세스가 종료되어 메모리에서 회수되고 제어 블록을 폐기한다.

### 휴식 상태

프로세스가 일시중단 되어 있는 상태로, 사용하던 데이터는 메모리에 남아있고 제어블록도 그대로 유지된다.  
프로세스를 모니터링해 재개될 때까지 대기 상태로 유지된다. 재개되는 경우 준비 상태로 전환되어 준비 큐로 추가된다.  
예를 들어 브라우저에서 유튜브를 시청하다 일시 정지하고 다른 프로세스로 화면을 전환하게 되면,  
제어블록과 데이터는 메모리에 남아있는 상태로 대기 상태로 유지되었다가, 다시 시청하게 되면 준비 큐로 전환되었다 실행된다.

### 보류 상태

악의적인 공격이라 판단하거나, 입출력이 지연될 경우, 메모리 부하로 해당 프로세스를 스왑영역으로 이동해야 할 때  
대기에서 보류 대기로, 준비에서 보류 준비로 전환된다. 프로세스가 재시작될 경우 다시 활성 상태로 들어간다.

<Space />

## 프로세스 문맥 교환

CPU를 점유한 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다.  
제어 블록에 작업 내용을 저장하고 상태를 변경한 후 다른 프로세스 제어 블록과 교환한다.

<Space />

## 프로세스 구조

읽기 전용인 `정적 할당 영역`과 크기가 유동적인 `동적 할당 영역`이있다.

### 정적 영역

- 코드 영역: 프로그램을 구성하는 코드 소스가 있는 영역이며 읽기 전용이다.
- 데이터 영역: 읽기 전용으로 정적인 정적인 문자, 상수, 파일 등이 저장되고 읽기 전용이다.  
  예로 `“Hello”, 100(int), [1,2,3,4](tuple)`

### 동적 영역

- 스택 영역: 하나의 스레드에는 하나의 스택 영역을 갖는데, 함수가 호출되는 환경(지역 변수, 호출 정보 등)이  
  저장된다. 스레드가 제거될 경우 해당 스택 영역 또한 제거된다.
- 힙 영역: 동적인 변수나 가변 데이터들이 저장되는 공간이다. 예로 객체를 생각하면 된다.

<Space />

## 프로세스 생성과 복사

- fork(): 부모 프로세스로부터 모든 데이터와 코드를 복사한 새로운 자식 프로세스를 생성한다.  
  새로 생성된 프로세스는 자신의 식별자 PID, 부모의 CPID, 자식의 PPID가 바뀐다.  
  메모리 공간을 차지하는 위치가 다르므로 메모리 관련 정보도 바뀐다.  
  저장 공간에서 새로 실행시키는 것이 아닌 기존 메모리에서 복사하기 때문에 생성 속도가 빠르다.  
  자식 프로세스가 종료되면 부모 프로세스가 자원을 정리할 수 있으므로 운영체제 자원면에서 효율적이다.  
  하지만 부모의 모든 데이터를 그대로 사용하기 때문에 필요하지 않는 데이터도 갖고 있어 무겁다.
- exec(): 기존 프로세스로부터 이미 만들어진 제어 블록, 메모리 영역, 부모 자식 관계의 구조체를 재활용해  
  새로운 프로세스를 생성한다. 프로세스를 새로 생성하려면 제어 블록을 만들고 메모리 자리도 확보해야 하는 작업을  
  하지 않아도 되기 때문에 효율적이다.

<Space />

## 스레드

프로세스 코드에 정의된 절차에 따라 CPU에 작업 수행을 요청하는 `실행 단위`다.  
기본적으로 하나의 프로세스에는 하나의 스레드가 반드시 존재한다.  
운영체제 입장에선 프로세스가 작업 단위이고, CPU 입장에선 스레드가 작업 단위다.  
예로 인테리어(프로세스)라는 큰 작업에서 타일 깔기 전등 설치하기 등의 작은 작업을 스레드라 할 수 있다.

> 작업의 크기를 나누어 보자면 `Job` → `Task(프로세스)` → `Operation(스레드)`다.

<Space />

## 멀티 스레딩

스레드가 2개 이상 존재할 때를 `멀티 스레딩`이라 한다.  
스레드들은 프로세스 내부에서 강하게 연결되어 있으며, 하나의 스레드에서 발생하는 문제가  
전체 스레드에 영향을 미친다. CPU는 여러 스레드를 동시에 처리하는 `병렬 처리 기법`을 사용한다.

<br />

프로세스 복사 호출(fork())은 자식 프로세스를 생성할 때 부모의 모든 환경을 그대로 가져오기 때문에,  
메모리에 중복되는 데이터들이 발생한다. 하지만 프로세스를 생성하는 것보다 스레드를 추가하게 되면,  
같은 프로세스 안에 하나의 스레드로 존재하게 되면서 자원이 중복되는 메모리 낭비가 발생하지 않게 된다.

<Space />

## 참조

[쉽게 배우는 운영체제 - 한빛 아카데미](https://product.kyobobook.co.kr/detail/S000001743685)  
[널널한 개발자 - Process와 Thread의 차이](https://www.youtube.com/watch?v=x-Lp-h_pf9Q)  
[널널한 개발자 - 프로세스와 스레드 매우중요](https://www.youtube.com/watch?v=2i3dInwVeUM)  
[널널한 개발자 - 프로세스 상태와 문맥교환](https://www.youtube.com/watch?v=a2GDsaReFEA)  
[널널한 개발자 - 프로세스 생성과 복사 fork()와 exec()](https://www.youtube.com/watch?v=RzN18na94Wc&list=PLXvgR_grOs1DGFOeD792kHlRml0PhCe9l&index=12)
