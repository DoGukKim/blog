---
description: '물리 메모리와 스왑영역, 물리 메모리 분할 방식에 대해 알아보자!'
date: 2022-08-19 10:46:39
publish: true
tags: ['computer-science', 'operate-systems']
title: '물리 메모리'
thumbnail: ''
---

## 메모리 사전지식

메모리 셀은 기본 저장 단위이며 이진 수를 나타내는 0과 1을 저장하는 회로다.  
각 셀은 1bit 단위로 셀에 저장된 데이터를 접근할 수 있는 고유 주소가 있고 일반적으로 0번지 부터 시작한다.  
메모리 셀이 결합되어 더 많은 정보를 저장할 수 있는 바이트(8bit), 워드(16bit), 더블워드(32bit)와 같은 단위를  
형성하고, 각 메모리 단위는 고유한 주소를 갖으며 비트는 결합된 데이터 단위 내에서 고유한 주소를 갖는다.  
이렇게 여러 메모리 셀을 더 큰 단위로 결합함으로써 컴퓨터는 더 많은 양의 데이터를 더 효율적으로 저장하고 액세스할 수 있다.
메모리 주소는 일반적으로 16진수 형식(예: 0x1000)으로 표현되지만,  
메모리에 저장된 데이터는 일반적으로 이진수 형식(예: 01100101)으로 표현된다.

<Space />

## CPU bit와 메모리 관계

CPU 비트 값은 한 번에 다룰 수 있는 데이터의 최대 크기를 의미한다. CPU 내부 부품은 이 비트를 기준으로  
제작되고(레지스터, 연산 장치) 데이터를 전송하는 버스의 크기인 대역폭도 비트를 기준으로 정해진다.  
CPU bit는 가용할 수 있는 메모리 최대 크기를 결정하는데, 이는 실제 물리 메모리 크기를 말하는 것이 아니다.  
32비트 CPU는 최대 4GB, 최대 2^32개의 서로 다른 메모리 주소를 지정할 수 있는데,  
즉, 실제 물리 메모리 크기가 16GB여도 최대 4GB 메모리만 사용할 수 있다는 것이다.

<Space />

## 메모리 영역 구분

메모리 영역은 `운영체제 영역`과 `사용자 영역`이 있고 그 경계를 구분하는 `경계 레지스터`가 있다.  
모든 사용자 프로세스는 운영체제 영역을 제외한 메모리 공간에 실행된다.  
메모리 관리자는 작업마다 경계 레지스터 값을 벗어나는지 확인해 벗어날 경우 해당 프로세스를 종료한다.

<Space />

## 절대 주소, 상대 주소

- 절대 주소: 실제 램 메모리에 물리적 주소를 말한다. 메모리 주소 레지스터, 메모리 관리자가 사용하는 주소다.
- 상대 주소: 사용자 프로세스는 운영체제 영역을 침범할 수 없기 때문에,  
  메모리에 사용자 영역이 시작되는 주소를 0번지로 변경해 사용하는 방식이다.  
   메모리 관리자는 상대 주소를 활용할 때 `재배치 레지스터`를 활용해 절대주소로 변환하고 데이터를 가져온다.

<Space />

## 메모리 오버레이

프로그램의 크기가 실제 메모리 사이즈 보다 큰 경우 적당한 크기로 잘라 공간을 겹쳐 활용하는 방식이다.  
프로그램의 중요한 모듈만 메모리에 올리고 나머지 모듈은 필요에 따라 메모리에 올렸다 회수하거나 스왑 영역에 옮긴다.  
예로 그림판에서 중요한 모듈은 메모리에 올리고 그림판에서 수행되는 기능을 필요에 따라 메모리에 올린다.  
프로그램 카운터 레지스터가 어떠한 모듈을 가져올 것이고 내보낼 것인가를 결정하고,  
해당 모듈이 메모리에 없으면 메모리 관리자에게 요청한다.

<Space />

## 스왑

보조 기억 장치에 일정 영역을 메모리 부하 또는 데이터가 다시 사용될 수도 있는 경우를 위해 확보한 영역이다.  
사용자 프로세스는 램 메모리와 스왑 영역의 크기를 합쳐 전체 메모리로 인식하고 사용할 수 있다.  
스왑 영역은 메모리 관리자가 관리하고 데이터를 스왑 영역으로 보내는 것을 `스왑 아웃`, 반대를 `스왑 인`이라 한다.  
스왑 영역의 활용 예로 절전 모드가 있다. 램 메모리는 휘발성으로 전기가 끊기면 데이터가 휘발하기 때문에,  
절전 모드시 스왑 영역에 데이터를 저장해 놓는다. 따라서 절전 모드 해제 시에도 데이터를 보존할 수 있다.

<Space />

## 메모리 분할 방식과 할당

### 가변 분할 방식

프로세스의 크기에 따라 메모리 할당 용량이 각각 다르며, 데이터가 연속적으로 할당되어 연속 메모리 할당이라 한다.  
가변 분할 방식은 연속 메모리 할당으로 인해 메모리에 빈 영역이 있어도 서로 떨어져 있으면 프로세스를 배정하지 못하고,  
공간이 비었다고 해서 우선순위에 어긋나게 메모리를 할당할 수도 없기 때문에, 할당하지 못하는 작은 메모리 조각들이  
발생하는데 이를 `외부 단편화`라 한다. 이런 외부 단편화를 해결하기 위해 메모리 배치 방식이나 조각 모음을 사용한다.

<br />

**메모리 배치 방식**

- 최초 배치: 단편화를 고려하지 않고 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 배치하는 방법이다.
- 최적 배치: 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 배치하는 방법이다.
- 최악 배치: 메모리의 빈 공간을 모두 확인한 후 가장 큰 공간에 배치하는 방법이다.

**조각 모음**

메모리 배치 방식을 사용해도 단편화 현상이 발생하기 때문에, 이들과 함께 사용되어 이미 배치된 프로세스를 옆으로 옮겨  
빈 공간들을 하나의 `덩어리`로 만드는 방법이다. 조각 모음을 하려면 프로세스를 중지시키고, 이동하고, 주소를 바꾸고  
다시 시작하는 작업을 해야 하기 때문에 많은 시간이 걸린다.

<br />

### 고정 분할 방식

프로세스 크기와 상관없이 메모리 크기를 같은 크기로 나누어 할당된다.  
프로세스가 메모리의 여러 조각에 나뉘어 배치되므로 연속적으로 할당되지 않는다. 이를 비연속 메모리 할당이라 한다.  
일정하게 나뉜 메모리 크기보다 작은 프로세스가 배치될 경우 낭비되는 공간이 발생하는데, 이를 `내부 단편화`라 한다.  
고정 분할 방식은 조각 모음을 할 수 없기 때문에 분할되는 공간의 크기를 조절해 단편화를 최소화한다.  
대기하는 프로세스들이 비연속 메모리 할당으로 공간이 발생하면 빠르게 메모리에 배치되어 실행된다.

<Space />

## 참조

[쉽게 배우는 운영체제 - 한빛 아카데미](https://product.kyobobook.co.kr/detail/S000001743685)  
[널널한 개발자 - 메모리 관리 개요](https://www.youtube.com/watch?v=qk7pfIwcNSU&list=PLXvgR_grOs1DGFOeD792kHlRml0PhCe9l&index=20)  
[널널한 개발자 - 절대주소와 상대주소](https://www.youtube.com/watch?v=GZEmF1iPBvw&list=PLXvgR_grOs1DGFOeD792kHlRml0PhCe9l&index=21)  
[널널한 개발자 - 메모리 오버레이와 스왑](https://www.youtube.com/watch?v=dtEGd30T8Rk&list=PLXvgR_grOs1DGFOeD792kHlRml0PhCe9l&index=21)  
[널널한 개발자 - (물리)메모리 분할 방식](https://www.youtube.com/watch?v=Q3VL9Y_ITSg&list=PLXvgR_grOs1DGFOeD792kHlRml0PhCe9l&index=22)
